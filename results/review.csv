Topic,Decision,Reason,Final,Answer,Explain,Original,Review JSON
計算機網路 - Routing,accept,題目清楚，選項合理，且答案唯一,"題目：在距離向量路由協定中，為減輕 count-to-infinity 問題而採用的「Split Horizon with Poison Reverse」主要是透過哪種方式避免路由迴圈？

(A) 將從某鄰居學得的路徑，對該鄰居宣告為不可達（無限度量）  
(B) 使用序號以防止舊的連結狀態廣播（LSA）被接受  
(C) 只對鏈路成本最低的鄰居進行路由更新  
(D) 對所有鄰居同時觸發更新以加速收斂  

答案：A  
解析：Poison Reverse 會把從某鄰居學到的路由以無限度量回宣給同一鄰居，避免兩點間的路由來回宣告造成迴圈與 count-to-infinity；B屬於連結狀態協定機制，C與D無法直接避免迴圈。",A,Poison Reverse 會把從某鄰居學到的路由以無限度量回宣給同一鄰居，避免兩點間的路由來回宣告造成迴圈與 count-to-infinity；B屬於連結狀態協定機制，C與D無法直接避免迴圈。,"題目：在距離向量路由協定中，為減輕 count-to-infinity 問題而採用的「Split Horizon with Poison Reverse」主要是透過哪種方式避免路由迴圈？
(A) 將從某鄰居學得的路徑，對該鄰居宣告為不可達（無限度量）
(B) 使用序號以防止舊的連結狀態廣播（LSA）被接受
(C) 只對鏈路成本最低的鄰居進行路由更新
(D) 對所有鄰居同時觸發更新以加速收斂

答案：A
解析：Poison Reverse 會把從某鄰居學到的路由以無限度量回宣給同一鄰居，避免兩點間的路由來回宣告造成迴圈與 count-to-infinity；B屬於連結狀態協定機制，C與D無法直接避免迴圈。","{""decision"": ""accept"", ""reason"": ""題目清楚，選項合理，且答案唯一"", ""final_question"": ""在距離向量路由協定中，為減輕 count-to-infinity 問題而採用的「Split Horizon with Poison Reverse」主要是透過哪種方式避免路由迴圈？\n\n(A) 將從某鄰居學得的路徑，對該鄰居宣告為不可達（無限度量）  \n(B) 使用序號以防止舊的連結狀態廣播（LSA）被接受  \n(C) 只對鏈路成本最低的鄰居進行路由更新  \n(D) 對所有鄰居同時觸發更新以加速收斂  \n\n### 答案：\nA  \n\n### 解析：\nPoison Reverse 會把從某鄰居學到的路由以無限度量回宣給同一鄰居，避免兩點間的路由來回宣告造成迴圈與 count-to-infinity；B屬於連結狀態協定機制，C與D無法直接避免迴圈。""}"
資料結構 - Heap,rewrite,題目缺乏詳細的選項和預期答案，應該指定合併的方式以及合併後的特性。,"題目：給定兩個分別含有 n 與 m 個元素的最小二元堆（以陣列表示），以下哪一項描述了將它們合併成一個最小二元堆的正確方式？
(A) 將第二個堆的元素逐一插入第一個堆中，維持最小堆的性質。
(B) 將兩個堆的元素合併為一個大陣列，然後重新構建最小堆。
(C) 直接將第二個堆的陣列添加到第一個堆的結尾，再進行堆調整。
(D) 僅僅取第一個堆的元素，不考慮第二個堆。
答案：B
解析：要合併兩個最小二元堆，最有效的方式是將它們的元素合併成一個大陣列並重新構建最小堆，以保證最小堆的性質。",B,要合併兩個最小二元堆，最有效的方式是將它們的元素合併成一個大陣列並重新構建最小堆，以保證最小堆的性質。,題目：給定兩個分別含有 n 與 m 個元素的最小二元堆（以陣列表示），要將它,"{""decision"": ""rewrite"", ""reason"": ""題目缺乏詳細的選項和預期答案，應該指定合併的方式以及合併後的特性。"", ""final_question"": ""給定兩個分別含有 n 與 m 個元素的最小二元堆（以陣列表示），以下哪一項描述了將它們合併成一個最小二元堆的正確方式？\n\nA. 將第二個堆的元素逐一插入第一個堆中，維持最小堆的性質。\nB. 將兩個堆的元素合併為一個大陣列，然後重新構建最小堆。\nC. 直接將第二個堆的陣列添加到第一個堆的結尾，再進行堆調整。\nD. 僅僅取第一個堆的元素，不考慮第二個堆。\n\n正確答案：B\n解析：要合併兩個最小二元堆，最有效的方式是將它們的元素合併成一個大陣列並重新構建最小堆，以保證最小堆的性質。""}"
計算機網路 - Routing,rewrite,題目不夠具體，缺少選項和背景說明，無法提供清晰的選擇和正確答案。,"題目：關於路由協定 RIP，下列敘述哪一項是正確的？
(A) RIP 使用距離向量算法來計算路由  
(B) RIP 的最大跳數限制為 10 跳  
(C) RIP 每 5 秒發送一次路由更新  
(D) RIP 只適用於企業網絡  
答案：A  
解析：RIP（Routing Information Protocol）是一種基於距離向量的路由協定，它的最大跳數限制為 15 跳（16 跳表示不可達），更新間隔通常為 30 秒，而不僅限於企業網絡。",A,RIP（Routing Information Protocol）是一種基於距離向量的路由協定，它的最大跳數限制為 15 跳（16 跳表示不可達），更新間隔通常為 30 秒，而不僅限於企業網絡。,題目：關於路由協定 RIP,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，缺少選項和背景說明，無法提供清晰的選擇和正確答案。"", ""final_question"": ""關於路由協定 RIP，下列敘述哪一項是正確的？\n\nA. RIP 使用距離向量算法來計算路由\nB. RIP 的最大跳數限制為 10 跳\nC. RIP 每 5 秒發送一次路由更新\nD. RIP 只適用於企業網絡\n\n正確答案：A\n\n解析：RIP（Routing Information Protocol）是一種基於距離向量的路由協定，它的最大跳數限制為 15 跳（16 跳表示不可達），更新間隔通常為 30 秒，而不僅限於企業網絡。""}"
資料結構 - Heap,rewrite,題目的答案和解析部分存在不正確或不完整的描述，需重新檢查時間複雜度的計算過程。,,N/A,N/A,"題目：對一個包含 n 個元素的無序陣列，使用二元最大堆的自底向上建堆（Floyd 建堆）來建立堆，其最壞情況時間複雜度為何？
(A) O(n)
(B) O(n log n)
(C) O(log n)
(D) O(n^2)
答案：A
解析：自底向上建堆對每個非葉節點執行下沉，節點可下沉的步數與其高度成正比，而該高度的節點數量呈指數遞減，總","{""decision"": ""rewrite"", ""reason"": ""題目的答案和解析部分存在不正確或不完整的描述，需重新檢查時間複雜度的計算過程。"", ""final_question"": {""question"": ""對一個包含 n 個元素的無序陣列，使用二元最大堆的自底向上建堆（Floyd 建堆）來建立堆，其最壞情況時間複雜度為何？"", ""options"": {""A"": ""O(n)"", ""B"": ""O(n log n)"", ""C"": ""O(log n)"", ""D"": ""O(n^2)""}, ""answer"": ""A"", ""explanation"": ""自底向上建堆的時間複雜度為 O(n)，因為雖然每個節點的下沉操作最多需要 O(h) 的時間，但樹的高度 h 為 log n，且底部的節點多，整體計算後得到的總時間是 O(n)。""}}"
資料結構 - 二元搜尋樹(BST),accept,題目清楚，選項合理，且答案唯一。,"題目：對於不含重複鍵的二元搜尋樹（BST），若要輸出節點的鍵值由大到小的排序，應使用下列何種遍歷方式？
(A) 前序遍歷：根-左-右  
(B) 中序遍歷：左-根-右  
(C) 後序遍歷：左-右-根  
(D) 反中序遍歷：右-根-左  

答案：D  
解析：BST 的中序遍歷（左-根-右）會得到由小到大的序列；要由大到小，則使用反中序遍歷（右-根-左）。",D,BST 的中序遍歷（左-根-右）會得到由小到大的序列；要由大到小，則使用反中序遍歷（右-根-左）。,"題目：對於不含重複鍵的二元搜尋樹（BST），若要輸出節點的鍵值由大到小的排序，應使用下列何種遍歷方式？
(A) 前序遍歷：根-左-右
(B) 中序遍歷：左-根-右
(C) 後序遍歷：左-右-根
(D) 反中序遍歷：右-根-左
答案：D
解析：BST 的中序遍歷（左-根-右）會得到由小到大的序列；要由大到小，則使用反中序遍歷（右-根-左）。","{""decision"": ""accept"", ""reason"": ""題目清楚，選項合理，且答案唯一。"", ""final_question"": ""對於不含重複鍵的二元搜尋樹（BST），若要輸出節點的鍵值由大到小的排序，應使用下列何種遍歷方式？\n\n(A) 前序遍歷：根-左-右  \n(B) 中序遍歷：左-根-右  \n(C) 後序遍歷：左-右-根  \n(D) 反中序遍歷：右-根-左  \n\n答案：D  \n\n解析：BST 的中序遍歷（左-根-右）會得到由小到大的序列；要由大到小，則使用反中序遍歷（右-根-左）。""}"
資料結構 - 陣列(Array),rewrite,解析有誤，正確的偏移量應為 i × n + j，且選項與解析需釐清。,,N/A,N/A,"題目：有一個 m×n 的二維陣列 A 以「列優先（row-major）」方式連續儲存在一維陣列 arr 中，採 0-based 索引。元素 A[i][j] 在 arr 中的索引位置為何？
(A) i + j × m
(B) i × n + j
(C) i × m + j
(D) i + j × n
答案：B
解析：列優先表示依列依序儲存，因此在 A[i][j] 前面有 i 列、每列 n 個元素，偏移量為 i×n，再加上同列內的 j，故為 i×n + j。選項 (A)(D) 混用欄優先或維度，(C) 錯把每列大小寫成 m。","{""decision"": ""rewrite"", ""reason"": ""解析有誤，正確的偏移量應為 i × n + j，且選項與解析需釐清。"", ""final_question"": {""question"": ""有一個 m×n 的二維陣列 A 以「列優先（row-major）」方式連續儲存在一維陣列 arr 中，採 0-based 索引。元素 A[i][j] 在 arr 中的索引位置為何？"", ""options"": {""A"": ""i + j × m"", ""B"": ""i × n + j"", ""C"": ""i × m + j"", ""D"": ""i + j × n""}, ""answer"": ""B"", ""explanation"": ""列優先表示依列依序儲存，因此在 A[i][j] 前面有 i 列，每列 n 個元素，偏移量為 i × n，再加上同列內的 j，故為 i × n + j。選項 (A) 和 (D) 混用欄優先或維度，(C) 錯把每列大小寫成 m。""}}"
演算法 - Greedy,rewrite,題目不夠具體，未提供選項，也沒有明確的答案。在知識範疇內，關於貪婪策略的問題應具體列舉出選項，並指明正確答案以便檢驗。,"題目：以下哪個問題可用單純的貪婪策略在多項式時間內解決？
(A) 最小生成樹問題
(B) 旅行商問題
(C) 背包問題
(D) 選擇問題
答案：A
解析：最小生成樹問題可以使用貪婪策略有效解決，而其他選項或需要更複雜的算法，或沒有確保最佳解的貪婪策略。",A,最小生成樹問題可以使用貪婪策略有效解決，而其他選項或需要更複雜的算法，或沒有確保最佳解的貪婪策略。,題目：以下哪個問題可用單純的貪婪策略在多項式時間內,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，未提供選項，也沒有明確的答案。在知識範疇內，關於貪婪策略的問題應具體列舉出選項，並指明正確答案以便檢驗。"", ""final_question"": ""以下哪個問題可用單純的貪婪策略在多項式時間內解決？\n\nA. 最小生成樹問題\nB. 旅行商問題\nC. 背包問題\nD. 選擇問題\n\n正確答案：A\n\n解析：最小生成樹問題可以使用貪婪策略有效解決，而其他選項或需要更複雜的算法，或沒有確保最佳解的貪婪策略。""}"
計算機網路 - Routing,rewrite,題目中的描述不夠準確，選項C雖然接近正確，但應明確指出會遭遇哪些問題，以及其他選項的描述也存在不正確的地方。,"題目：以下哪一個敘述最正確地比較距離向量與連結狀態路由協定？

(A) 距離向量使用洪泛傳送鏈路狀態封包，並以 Dijkstra 計算最短路徑樹  
(B) 連結狀態協定易發生 count-to-infinity 問題，需以 split horizon 緩解  
(C) 距離向量定期向鄰居傳遞整張路由表，可能遭遇路由迴圈與慢收斂  
(D) 連結狀態協定不需要任何拓樸資料庫，只依鄰居距離做決策  

答案：C  
解析：距離向量協定（如 RIP）定期向鄰居傳送整個路由表，若存在拓撲變化，可能導致路由迴圈與慢收斂的問題。",C,距離向量協定（如 RIP）定期向鄰居傳送整個路由表，若存在拓撲變化，可能導致路由迴圈與慢收斂的問題。,"題目：以下哪一個敘述最正確地比較距離向量與連結狀態路由協定？
(A) 距離向量使用洪泛傳送鏈路狀態封包，並以 Dijkstra 計算最短路徑樹
(B) 連結狀態協定易發生 count-to-infinity 問題，需以 split horizon 緩解
(C) 距離向量定期向鄰居傳遞整張路由表，可能遭遇路由迴圈與慢收斂
(D) 連結狀態協定不需要任何拓樸資料庫，只依鄰居距離做決策
答案：C
解析：距離向量協定（如 RIP","{""decision"": ""rewrite"", ""reason"": ""題目中的描述不夠準確，選項C雖然接近正確，但應明確指出會遭遇哪些問題，以及其他選項的描述也存在不正確的地方。"", ""final_question"": ""以下哪一個敘述最正確地比較距離向量與連結狀態路由協定？\n\n(A) 距離向量使用洪泛傳送鏈路狀態封包，並以 Dijkstra 計算最短路徑樹  \n(B) 連結狀態協定易發生 count-to-infinity 問題，需以 split horizon 緩解  \n(C) 距離向量定期向鄰居傳遞整張路由表，可能遭遇路由迴圈與慢收斂  \n(D) 連結狀態協定不需要任何拓樸資料庫，只依鄰居距離做決策  \n\n答案：C  \n解析：距離向量協定（如 RIP）定期向鄰居傳送整個路由表，若存在拓撲變化，可能導致路由迴圈與慢收斂的問題。""}"
資料結構 - 堆疊(Stack),rewrite,題目不夠具體，未明確指出需要的題型（選擇題、問答題等），並且缺乏選項和答案。,,N/A,N/A,題目（gpt5 空白）請出與 資料結構 - 堆疊(Stack) 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，未明確指出需要的題型（選擇題、問答題等），並且缺乏選項和答案。"", ""final_question"": {""question"": ""關於堆疊資料結構的特性，下列敘述哪一項是正確的？"", ""options"": [""A. 堆疊使用先進先出（FIFO）原則"", ""B. 堆疊使用後進先出（LIFO）原則"", ""C. 堆疊的插入與刪除操作只能在中間進行"", ""D. 堆疊可以被隨意訪問任意元素""], ""answer"": ""B"", ""explanation"": ""堆疊是遵循後進先出（LIFO）原則的資料結構，即最後加入的元素最先被移除。""}}"
計算機網路 - TCP,rewrite,題目不夠具體，未提供選項和答案，且沒有明確的考察重點。,,N/A,N/A,題目（gpt5 空白）請出與 計算機網路 - TCP 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，未提供選項和答案，且沒有明確的考察重點。"", ""final_question"": {""question"": ""TCP（傳輸控制協議）的主要特性是什麼？"", ""options"": [""A. 無連接性"", ""B. 提供可靠的資料傳輸"", ""C. 不進行流量控制"", ""D. 只支持單向資料傳輸""], ""answer"": ""B"", ""explanation"": ""TCP 是一種面向連接的協議，提供可靠的資料傳輸和流量控制，以及錯誤檢測等功能。""}}"
資料庫 - Index,rewrite,題目缺乏完整性，只有一個選項且沒有正確答案的指示，更需要其他選項以形成多選題。,"題目：關於資料庫索引的類型與適用情境，下列何者正確？
(A) B-Tree 索引適用於範圍查詢。
(B) Hash 索引適用於範圍查詢。
(C) GiST 索引不適用於空間資料。
(D) Bitmap 索引適合高更新頻率的列。
答案：A
解析：B-Tree 索引適合進行範圍查詢，而 Hash 索引則主要用於精確查詢。GiST 索引可以用於空間資料，而 Bitmap 索引適合於查詢頻率低的情況。",A,B-Tree 索引適合進行範圍查詢，而 Hash 索引則主要用於精確查詢。GiST 索引可以用於空間資料，而 Bitmap 索引適合於查詢頻率低的情況。,"題目：關於資料庫索引的類型與適用情境，下列何者正確？
(A) B-Tree 索引","{""decision"": ""rewrite"", ""reason"": ""題目缺乏完整性，只有一個選項且沒有正確答案的指示，更需要其他選項以形成多選題。"", ""final_question"": ""關於資料庫索引的類型與適用情境，下列何者正確？\n\n(A) B-Tree 索引適用於範圍查詢。\n(B) Hash 索引適用於範圍查詢。\n(C) GiST 索引不適用於空間資料。\n(D) Bitmap 索引適合高更新頻率的列。\n\n正確答案：A\n\n解析：B-Tree 索引適合進行範圍查詢，而 Hash 索引則主要用於精確查詢。GiST 索引可以用於空間資料，而 Bitmap 索引適合於查詢頻率低的情況。""}"
演算法 - Dynamic Programming,rewrite,題目不夠具體，未給出明確要求或選項，且未包含答案及解析。,,N/A,N/A,題目（gpt5 空白）請出與 演算法 - Dynamic Programming 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，未給出明確要求或選項，且未包含答案及解析。"", ""final_question"": {""question"": ""在以下哪個問題中，可以使用動態規劃（Dynamic Programming）來有效解決？"", ""options"": [""A. 二分搜尋法的查找問題"", ""B. 背包問題（0/1 Knapsack Problem）"", ""C. 快速排序的實現"", ""D. 字符串的直接比較""], ""answer"": ""B"", ""explanation"": ""背包問題是一個典型的動態規劃問題，旨在通過逐步積累最佳解來解決選擇和容量的衝突。""}}"
作業系統 - 排程(Scheduling),rewrite,題目不清楚，缺少具體的考察點和選項，無法確定考核的知識面。,,N/A,N/A,題目（gpt5 空白）請出與 作業系統 - 排程(Scheduling) 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不清楚，缺少具體的考察點和選項，無法確定考核的知識面。"", ""final_question"": {""question"": ""以下哪一種排程演算法會優先考慮到進程的周轉時間？"", ""options"": [""A. 先來先服務 (FCFS)"", ""B. 短作業優先 (SJF)"", ""C. 優先權排程"", ""D. 鬆弛排程 (Round Robin)""], ""answer"": ""B"", ""explanation"": ""短作業優先 (SJF) 演算法會優先考慮到較短的作業，從而最小化進程的周轉時間，提升整體效率。""}}"
演算法 - Sorting,rewrite,題目不明確，缺少具體問題與選項。,,N/A,N/A,題目（gpt5 空白）請出與 演算法 - Sorting 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不明確，缺少具體問題與選項。"", ""final_question"": {""question"": ""以下哪一種排序演算法的最佳時間複雜度為 O(n log n)？"", ""options"": [""A. 冒泡排序 (Bubble Sort)"", ""B. 快速排序 (Quick Sort)"", ""C. 插入排序 (Insertion Sort)"", ""D. 選擇排序 (Selection Sort)""], ""answer"": ""B"", ""explanation"": ""快速排序在最佳情況下的時間複雜度為 O(n log n)，而其他選項的最佳複雜度均無法達到此效果。""}}"
資料庫 - Index,rewrite,題目不夠清楚，缺少具體問題和選項。,"題目：以下哪項描述最正確地反映了資料庫索引（Index）的作用？
(A) 資料庫索引會導致查詢速度變慢。  
(B) 資料庫索引不能提高查詢的效率。  
(C) 資料庫索引是一種資料結構，可以加快查詢操作的速度。  
(D) 資料庫索引僅用於儲存非結構化數據。

答案：C  
解析：資料庫索引是一個用來提高資料查詢速度的資料結構，透過索引，資料庫能夠更快地定位到所需的資料。",C,資料庫索引是一個用來提高資料查詢速度的資料結構，透過索引，資料庫能夠更快地定位到所需的資料。,題目（gpt5 空白）請出與 資料庫 - Index 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠清楚，缺少具體問題和選項。"", ""final_question"": ""以下哪項描述最正確地反映了資料庫索引（Index）的作用？\n\nA. 資料庫索引會導致查詢速度變慢。  \nB. 資料庫索引不能提高查詢的效率。  \nC. 資料庫索引是一種資料結構，可以加快查詢操作的速度。  \nD. 資料庫索引僅用於儲存非結構化數據。\n\n正確答案：C. 資料庫索引是一種資料結構，可以加快查詢操作的速度。\n\n解析：資料庫索引是一個用來提高資料查詢速度的資料結構，透過索引，資料庫能夠更快地定位到所需的資料。""}"
資料結構 - 二元搜尋樹(BST),rewrite,題目不夠具體，缺少選項和答案，需要針對二元搜尋樹提出具體問題。,,N/A,N/A,題目（gpt5 空白）請出與 資料結構 - 二元搜尋樹(BST) 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，缺少選項和答案，需要針對二元搜尋樹提出具體問題。"", ""final_question"": {""question"": ""以下描述中哪一項是二元搜尋樹（BST）的特性？"", ""options"": [""A. 所有節點的值都大於其左子樹所有節點的值。"", ""B. 所有節點的值都小於其右子樹所有節點的值。"", ""C. 每個節點最多有兩個子節點。"", ""D. 所有上述選項都是二元搜尋樹的特性。""], ""answer"": ""D"", ""explanation"": ""二元搜尋樹的特性包括：每個節點的值大於其左子樹的所有節點的值，小於其右子樹的所有節點的值，並且每個節點最多有兩個子節點。""}}"
演算法 - Searching,rewrite,題目要求搜尋算法在期望時間上優於二分搜尋，但選項只給了一種(線性)，且線性搜尋無法優於二分搜尋。因此選項不合理，需增加選項並引導清晰。,"題目：在一個已排序且鍵值近似均勻分佈的長度為 n 的陣列中，對單次查找，以下哪種搜尋演算法在期望時間複雜度上可優於二分搜尋？
(A) 線性搜尋  
(B) 插值搜尋  
(C) 幾何搜尋  
(D) 分裂搜尋  
答案：B  
解析：插值搜尋在特定的均勻分佈情況下，其期望時間複雜度可優於二分搜尋，而線性搜尋則不可能優於二分搜尋。",B,插值搜尋在特定的均勻分佈情況下，其期望時間複雜度可優於二分搜尋，而線性搜尋則不可能優於二分搜尋。,"題目：在一個已排序且鍵值近似均勻分佈的長度為 n 陣列中，對單次查找，以下哪種搜尋演算法在期望時間複雜度上可優於二分搜尋？
(A) 線性","{""decision"": ""rewrite"", ""reason"": ""題目要求搜尋算法在期望時間上優於二分搜尋，但選項只給了一種(線性)，且線性搜尋無法優於二分搜尋。因此選項不合理，需增加選項並引導清晰。"", ""final_question"": ""在一個已排序且鍵值近似均勻分佈的長度為 n 的陣列中，對單次查找，以下哪種搜尋演算法在期望時間複雜度上可優於二分搜尋？\n\n(A) 線性搜尋\n(B) 插值搜尋\n(C) 幾何搜尋\n(D) 分裂搜尋\n\n答案： (B) 插值搜尋\n\n解析：插值搜尋在特定的均勻分佈情況下，其期望時間複雜度可優於二分搜尋，而線性搜尋則不可能優於二分搜尋。""}"
資料庫 - Transaction,accept,題目清楚，選項合理，且答案唯一。,"題目：在遵循 SQL 標準的交易隔離級別中，哪一個隔離級別能防止髒讀與不可重複讀，但仍可能發生幻讀？

(A) Read Uncommitted  
(B) Read Committed  
(C) Repeatable Read  
(D) Serializable  

答案：C  
解析：SQL 標準下，Repeatable Read 可避免髒讀與不可重複讀，但仍可能出現幻讀；Serializable 才能避免所有三種異常（髒讀、不可重複讀、幻讀）。Read Committed 只能避免髒讀；Read Uncommitted 連髒讀也無法避免。",C,SQL 標準下，Repeatable Read 可避免髒讀與不可重複讀，但仍可能出現幻讀；Serializable 才能避免所有三種異常（髒讀、不可重複讀、幻讀）。Read Committed 只能避免髒讀；Read Uncommitted 連髒讀也無法避免。,"題目：在遵循 SQL 標準的交易隔離級別中，哪一個隔離級別能防止髒讀與不可重複讀，但仍可能發生幻讀？
(A) Read Uncommitted
(B) Read Committed
(C) Repeatable Read
(D) Serializable
答案：C
解析：SQL 標準下，Repeatable Read 可避免髒讀與不可重複讀，但仍可能出現幻讀；Serializable 才能避免所有三種異常（髒讀、不可重複讀、幻讀）。Read Committed 只能避免髒讀；Read Uncommitted 連髒讀也無法避免。","{""decision"": ""accept"", ""reason"": ""題目清楚，選項合理，且答案唯一。"", ""final_question"": ""在遵循 SQL 標準的交易隔離級別中，哪一個隔離級別能防止髒讀與不可重複讀，但仍可能發生幻讀？\n\n(A) Read Uncommitted  \n(B) Read Committed  \n(C) Repeatable Read  \n(D) Serializable  \n\n**答案：** C  \n\n**解析：** SQL 標準下，Repeatable Read 可避免髒讀與不可重複讀，但仍可能出現幻讀；Serializable 才能避免所有三種異常（髒讀、不可重複讀、幻讀）。Read Committed 只能避免髒讀；Read Uncommitted 連髒讀也無法避免。""}"
計算機網路 - TCP,rewrite,題目不具體，缺乏選項及答案，無法進行有效的審題。,"題目：下列關於計算機網路中 TCP (傳輸控制協定) 的敘述，何者是正確的？
(A) TCP 是一種無連接的傳輸協定。
(B) TCP 提供可靠的數據傳輸。
(C) TCP 不使用擁塞控制機制。
(D) TCP 在數據傳輸時不進行錯誤檢查。

答案：B  
解析：TCP (傳輸控制協定) 是一種面向連接的協定，提供可靠的數據傳輸功能，包括錯誤檢查和擁塞控制機制。",B,TCP (傳輸控制協定) 是一種面向連接的協定，提供可靠的數據傳輸功能，包括錯誤檢查和擁塞控制機制。,題目（gpt5 空白）請出與 計算機網路 - TCP 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不具體，缺乏選項及答案，無法進行有效的審題。"", ""final_question"": ""下列關於計算機網路中 TCP (傳輸控制協定) 的敘述，何者是正確的？\n\nA. TCP 是一種無連接的傳輸協定。\nB. TCP 提供可靠的數據傳輸。\nC. TCP 不使用擁塞控制機制。\nD. TCP 在數據傳輸時不進行錯誤檢查。\n\n正確答案：B\n\n解析：TCP (傳輸控制協定) 是一種面向連接的協定，提供可靠的數據傳輸功能，包括錯誤檢查和擁塞控制機制。""}"
計算機網路 - Routing,rewrite,題目不夠具體，未提供選項，無法清楚評估問題，也缺乏唯一答案的可能性。,"題目：以下哪一項是路由器選擇最佳路徑的常見協定？
(A) IP
(B) TCP
(C) BGP
(D) HTTP
答案：C
解析：BGP（邊界網路協定）是一種用於互聯網上路由選擇的協定，幫助路由器選擇最佳的資料傳輸路徑。",C,BGP（邊界網路協定）是一種用於互聯網上路由選擇的協定，幫助路由器選擇最佳的資料傳輸路徑。,題目（gpt5 空白）請出與 計算機網路 - Routing 有關的題目。,"{""decision"": ""rewrite"", ""reason"": ""題目不夠具體，未提供選項，無法清楚評估問題，也缺乏唯一答案的可能性。"", ""final_question"": ""以下哪一項是路由器選擇最佳路徑的常見協定？\nA) IP\nB) TCP\nC) BGP\nD) HTTP\n\n答案：C) BGP\n\n解析：BGP（邊界網路協定）是一種用於互聯網上路由選擇的協定，幫助路由器選擇最佳的資料傳輸路徑。""}"
